# Receipt-Engine プロジェクト設計方針

## 役割分担

| 担当 | 役割 | 使う場所 |
|------|------|----------|
| **Claude AI**（claude.ai / デスクトップアプリ） | ブレスト・設計・問題分析・指示書作成 | この `specs/` フォルダに指示書を書く |
| **Claude Code** | 実装・コード修正・テスト | `Receipt_Manager_v2` 内のGASファイルを編集 |
| **人間** | 最終判断・顧客側GASの設定・動作確認 | 顧客側スクリプトエディタ、スプレッドシート |

## 開発フロー

```
1. 人間 + Claude AI でブレスト・設計
       ↓
2. Claude AI が指示書を specs/ に書き込む
       ↓
3. 人間が Claude Code に「specs/XX を読んで実装して」と指示
       ↓
4. Claude Code が実装
       ↓
5. Claude Code が完了報告（人間経由で Claude AI にも共有）
       ↓
6. Claude AI が指示書に「実装完了記録」を追記
       ↓
7. 人間が clasp push + GitHub push + 顧客側の設定
       ↓
8. 動作確認 → 問題あれば 1 に戻る
```

## アーキテクチャ

```
Receipt-Engine（GASライブラリ）
  ├─ ロジックはすべてここ
  ├─ Claude Code が実装する対象
  └─ clasp push でデプロイ

顧客用GAS（各顧客のスプレッドシートにバウンド）
  ├─ Receipt-Engine をライブラリとして読み込む
  ├─ ラッパー関数で呼び出すだけ
  ├─ トリガーもここで設定
  └─ 人間が手動で管理（Claude Code のスコープ外）
```

## 技術スタック

- **レシート読み込み**：Gemini Flash
- **検証**：GPT-5
- **実行環境**：Google Apps Script
- **ソース管理**：Git + GitHub
- **デプロイ**：clasp

## 設計上の原則

1. **既存を壊さない**：新機能は既存関数を内部で呼び出す形で追加する
2. **ライブラリに集約**：ロジックはすべて Receipt-Engine 側。顧客側は薄いラッパーだけ
3. **段階的に進める**：大きな機能は第1弾・第2弾のように分けて、動作確認しながら拡張
4. **判断の根拠を残す**：なぜその設計にしたかを指示書に書く（半年後の自分やAIが読んでもわかるように）
5. **安全側に倒す**：自動化で迷ったら人間確認に回す（自動OKの条件は厳しめに設定）

## ステータス体系

A列のメインステータス（Gemini読み込み時に付与）：

| ステータス | 意味 | 自動検証の対象？ |
|-----------|------|----------------|
| `OK` | 問題なし | ✗ |
| `CHECK` | 整合性に疑問 | ✓ |
| `ERROR` | 基本情報欠落 | ✓ |
| `COMPOUND` | 複合仕訳 | △（不課税0円なら対象、0円超は人間確認） |
| `HAND` | 手書き | ✗ |

17列目の検証ステータス（GPT-5検証後に付与）：

| ステータス | 意味 |
|-----------|------|
| 🤖 自動承認 | GPT-5検証で3条件クリア → 自動でOKに変更済み |
| ✅ 手動承認 | 人間が確認してOKにした |
| 🟡要確認 | GPT-5検証したが条件未達 → 人間確認が必要 |
| 🟢 / 🔴 / 🔧 | 既存の検証ステータス |

## 今後の開発予定

| 順番 | 内容 | 状態 |
|------|------|------|
| 第1弾 | 自動検証＋自動承認 | ✅ 完了 |
| 第2弾 | アラート・監視（確度低下検知、メール通知など） | 🔜 次回 |
| 第3弾 | ダッシュボード・精度レポート | 📝 構想段階 |
